{"ast":null,"code":"/*\n * Simon Last, Sept 2013\n * http://simonlast.org\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\nconst pkg = require('../package.json');\nconst {\n  nextTick\n} = require('process');\nconst defaults = {\n  ttl: false,\n  logging: false,\n  encoding: 'utf8',\n  parse: JSON.parse,\n  stringify: JSON.stringify,\n  forgiveParseErrors: false,\n  expiredInterval: 2 * 60 * 1000,\n  /* every 2 minutes */\n  dir: '.' + pkg.name + '/storage',\n  writeQueue: true,\n  writeQueueIntervalMs: 1000,\n  writeQueueWriteOnlyLast: true\n};\nconst defaultTTL = 24 * 60 * 60 * 1000; /* if ttl is truthy but it's not a number, use 24h as default */\n\nconst isFunction = function (fn) {\n  return typeof fn === 'function';\n};\nconst isNumber = function (n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\nconst isDate = function (d) {\n  return Object.prototype.toString.call(d) === '[object Date]';\n};\nconst isValidDate = function (d) {\n  return isDate(d) && !isNaN(d);\n};\nconst isFutureDate = function (d) {\n  return isValidDate(d) && d.getTime() > +new Date();\n};\nconst sha256 = function (key) {\n  return crypto.createHash('sha256').update(key).digest('hex');\n};\nconst isValidStorageFileContent = function (content) {\n  return content && content.key;\n};\nconst isExpired = function (datum) {\n  return datum && datum.ttl && datum.ttl < new Date().getTime();\n};\nconst isNotExpired = function (datum) {\n  return !isExpired(datum);\n};\nconst resolveDir = function (dir) {\n  dir = path.normalize(dir);\n  if (path.isAbsolute(dir)) {\n    return dir;\n  }\n  return path.join(process.cwd(), dir);\n};\nconst LocalStorage = function (options) {\n  if (!(this instanceof LocalStorage)) {\n    return new LocalStorage(options);\n  }\n  this.setOptions(options);\n};\nLocalStorage.prototype = {\n  init: async function (options) {\n    if (options) {\n      this.setOptions(options);\n    }\n    await this.ensureDirectory(this.options.dir);\n    if (this.options.expiredInterval) {\n      this.startExpiredKeysInterval();\n    }\n    this.q = {};\n    this.startWriteQueueInterval();\n    return this.options;\n  },\n  initSync: function (options) {\n    if (options) {\n      this.setOptions(options);\n    }\n    this.ensureDirectorySync(this.options.dir);\n    if (this.options.expiredInterval) {\n      this.startExpiredKeysInterval();\n    }\n    this.q = {};\n    this.startWriteQueueInterval();\n    return this.options;\n  },\n  setOptions: function (userOptions) {\n    let options = {};\n    if (!userOptions) {\n      options = defaults;\n    } else {\n      for (let key in defaults) {\n        if (userOptions.hasOwnProperty(key)) {\n          options[key] = userOptions[key];\n        } else {\n          options[key] = this.options && this.options[key] != null ? this.options[key] : defaults[key];\n        }\n      }\n      options.dir = resolveDir(options.dir);\n      options.ttl = options.ttl ? isNumber(options.ttl) && options.ttl > 0 ? options.ttl : defaultTTL : false;\n    }\n\n    // Check to see if we received an external logging function\n    if (isFunction(options.logging)) {\n      // Overwrite log function with external logging function\n      this.log = options.logging;\n      options.logging = true;\n    }\n    this.options = options;\n  },\n  data: function () {\n    return this.readDirectory(this.options.dir);\n  },\n  keys: async function (filter) {\n    let data = await this.data();\n    if (filter) {\n      data = data.filter(filter);\n    }\n    return data.map(datum => datum.key);\n  },\n  values: async function (filter) {\n    let data = await this.data();\n    if (filter) {\n      data = data.filter(filter);\n    }\n    return data.map(datum => datum.value);\n  },\n  length: async function (filter) {\n    let data = await this.data();\n    if (filter) {\n      data = data.filter(filter);\n    }\n    return data.length;\n  },\n  forEach: async function (callback) {\n    let data = await this.data();\n    for (let d of data) {\n      await callback(d);\n    }\n  },\n  valuesWithKeyMatch: function (match) {\n    match = match || /.*/;\n    let filter = match instanceof RegExp ? datum => match.test(datum.key) : datum => datum.key.indexOf(match) !== -1;\n    return this.values(filter);\n  },\n  set: function (key, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.setItem(key, value, options);\n  },\n  setItem: function (key, datumValue) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let value = this.copy(datumValue);\n    let ttl = this.calcTTL(options.ttl);\n    this.log(\"set ('\".concat(key, \"': '\").concat(this.stringify(value), \"')\"));\n    let datum = {\n      key,\n      value,\n      ttl\n    };\n    return this.queueWriteFile(this.getDatumPath(key), datum);\n  },\n  update: function (key, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.updateItem(key, value, options);\n  },\n  updateItem: async function (key, datumValue) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let previousDatum = await this.getDatum(key);\n    if (previousDatum && isNotExpired(previousDatum)) {\n      let newDatumValue = this.copy(datumValue);\n      let ttl;\n      if (options.ttl) {\n        ttl = this.calcTTL(options.ttl);\n      } else {\n        ttl = previousDatum.ttl;\n      }\n      this.log(\"update ('\".concat(key, \"': '\").concat(this.stringify(newDatumValue), \"')\"));\n      let datum = {\n        key,\n        value: newDatumValue,\n        ttl\n      };\n      return this.queueWriteFile(this.getDatumPath(key), datum);\n    } else {\n      return this.setItem(key, datumValue, options);\n    }\n  },\n  get: function (key) {\n    return this.getItem(key);\n  },\n  getItem: async function (key) {\n    let datum = await this.getDatum(key);\n    if (isExpired(datum)) {\n      this.log(\"\".concat(key, \" has expired\"));\n      await this.removeItem(key);\n    } else {\n      return datum.value;\n    }\n  },\n  getDatum: function (key) {\n    return this.readFile(this.getDatumPath(key));\n  },\n  getRawDatum: function (key) {\n    return this.readFile(this.getDatumPath(key), {\n      raw: true\n    });\n  },\n  getDatumValue: async function (key) {\n    let datum = await this.getDatum(key);\n    return datum && datum.value;\n  },\n  getDatumPath: function (key) {\n    return path.join(this.options.dir, sha256(key));\n  },\n  del: function (key) {\n    return this.removeItem(key);\n  },\n  rm: function (key) {\n    return this.removeItem(key);\n  },\n  removeItem: function (key) {\n    return this.deleteFile(this.getDatumPath(key));\n  },\n  removeExpiredItems: async function () {\n    let keys = await this.keys(isExpired);\n    for (let key of keys) {\n      await this.removeItem(key);\n    }\n  },\n  clear: async function () {\n    let data = await this.data();\n    for (let d of data) {\n      await this.removeItem(d.key);\n    }\n  },\n  ensureDirectory: function (dir) {\n    return new Promise((resolve, reject) => {\n      let result = {\n        dir: dir\n      };\n      fs.access(dir, accessErr => {\n        if (!accessErr) {\n          return resolve(result);\n        } else {\n          fs.mkdir(dir, {\n            recursive: true\n          }, err => {\n            if (err) {\n              return reject(err);\n            }\n            this.log('created ' + dir);\n            resolve(result);\n          });\n        }\n      });\n    });\n  },\n  ensureDirectorySync: function (dir) {\n    let result = {\n      dir: dir\n    };\n    try {\n      fs.accessSync(dir);\n      return result;\n    } catch (e) {\n      fs.mkdirSync(dir, {\n        recursive: true\n      });\n      this.log('created ' + dir);\n      return result;\n    }\n  },\n  readDirectory: function (dir) {\n    return new Promise((resolve, reject) => {\n      //check to see if dir is present\n      fs.access(dir, accessErr => {\n        if (!accessErr) {\n          //load data\n          fs.readdir(dir, async (err, arr) => {\n            if (err) {\n              return reject(err);\n            }\n            let data = [];\n            try {\n              for (let currentFile of arr) {\n                if (currentFile[0] !== '.') {\n                  data.push(await this.readFile(path.join(this.options.dir, currentFile)));\n                }\n              }\n            } catch (err) {\n              reject(err);\n            }\n            resolve(data);\n          });\n        } else {\n          reject(new Error(\"[node-persist][readDirectory] \".concat(dir, \" does not exists!\")));\n        }\n      });\n    });\n  },\n  readFile: function (file) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise((resolve, reject) => {\n      fs.readFile(file, this.options.encoding, (err, text) => {\n        if (err) {\n          /* Only throw the error if the error is something else other than the file doesn't exist */\n          if (err.code === 'ENOENT') {\n            this.log(\"\".concat(file, \" does not exist, returning undefined value\"));\n            resolve(options.raw ? '{}' : {});\n          } else {\n            return reject(err);\n          }\n        }\n        let input = options.raw ? text : this.parse(text);\n        if (!options.raw && !isValidStorageFileContent(input)) {\n          return this.options.forgiveParseErrors ? resolve(options.raw ? '{}' : {}) : reject(new Error(\"[node-persist][readFile] \".concat(file, \" does not look like a valid storage file!\")));\n        }\n        resolve(input);\n      });\n    });\n  },\n  queueWriteFile: async function (file, content) {\n    if (this.options.writeQueue === false) {\n      return this.writeFile(file, content);\n    }\n    this.q[file] = this.q[file] || [];\n    nextTick(() => {\n      this.startWriteQueueInterval();\n    });\n    return new Promise((resolve, reject) => {\n      this.q[file].push({\n        content,\n        resolve,\n        reject\n      });\n    });\n  },\n  processWriteQueue: async function () {\n    if (this.processingWriteQueue) {\n      this.log('Still processing write queue, waiting...');\n      return;\n    }\n    this.processingWriteQueue = true;\n    const promises = Object.keys(this.q).map(async file => {\n      let writeItem;\n      if (this.options.writeQueueWriteOnlyLast) {\n        // lifo\n        writeItem = this.q[file].pop();\n      } else {\n        // fifo\n        writeItem = this.q[file].shift();\n      }\n      try {\n        const ret = await this.writeFile(file, writeItem.content);\n        if (this.options.writeQueueWriteOnlyLast) {\n          while (this.q[file].length) {\n            const writeItem0 = this.q[file].shift();\n            writeItem0.resolve(ret);\n          }\n        }\n        writeItem.resolve(ret);\n      } catch (e) {\n        while (this.q[file].length) {\n          const writeItem0 = this.q[file].shift();\n          writeItem0.reject(e);\n        }\n        writeItem.reject(e);\n      }\n      if (!this.q[file] || !this.q[file].length) {\n        delete this.q[file];\n      }\n    });\n    try {\n      await Promise.all(promises);\n    } finally {\n      this.processingWriteQueue = false;\n    }\n  },\n  startWriteQueueInterval: function () {\n    this.processWriteQueue();\n    if (!this._writeQueueInterval) {\n      this._writeQueueInterval = setInterval(() => this.processWriteQueue(), this.options.writeQueueIntervalMs || 1000);\n      this._writeQueueInterval.unref && this._writeQueueInterval.unref();\n    }\n  },\n  stopWriteQueueInterval: function () {\n    clearInterval(this._writeQueueInterval);\n  },\n  writeFile: async function (file, content) {\n    return new Promise((resolve, reject) => {\n      fs.writeFile(file, this.stringify(content), this.options.encoding, async err => {\n        if (err) {\n          return reject(err);\n        }\n        resolve({\n          file: file,\n          content: content\n        });\n        this.log('wrote: ' + file);\n      });\n    });\n  },\n  deleteFile: function (file) {\n    return new Promise((resolve, reject) => {\n      fs.access(file, accessErr => {\n        if (!accessErr) {\n          this.log(\"Removing file:\".concat(file));\n          fs.unlink(file, err => {\n            /* Only throw the error if the error is something else */\n            if (err && err.code !== 'ENOENT') {\n              return reject(err);\n            }\n            let result = {\n              file: file,\n              removed: !err,\n              existed: !accessErr\n            };\n            err && this.log(\"Failed to remove file:\".concat(file, \" because it doesn't exist anymore.\"));\n            resolve(result);\n          });\n        } else {\n          this.log(\"Not removing file:\".concat(file, \" because it doesn't exist\"));\n          let result = {\n            file: file,\n            removed: false,\n            existed: false\n          };\n          resolve(result);\n        }\n      });\n    });\n  },\n  stringify: function (obj) {\n    return this.options.stringify(obj);\n  },\n  parse: function (str) {\n    if (str == null) {\n      return undefined;\n    }\n    try {\n      return this.options.parse(str);\n    } catch (e) {\n      this.log('parse error: ', this.stringify(e), 'for:', str);\n      return undefined;\n    }\n  },\n  copy: function (value) {\n    // don't copy literals since they're passed by value\n    if (typeof value !== 'object') {\n      return value;\n    }\n    return this.parse(this.stringify(value));\n  },\n  startExpiredKeysInterval: function () {\n    this.stopExpiredKeysInterval();\n    this._expiredKeysInterval = setInterval(this.removeExpiredItems.bind(this), this.options.expiredInterval);\n    this._expiredKeysInterval.unref && this._expiredKeysInterval.unref();\n  },\n  stopExpiredKeysInterval: function () {\n    clearInterval(this._expiredKeysInterval);\n  },\n  log: function () {\n    this.options && this.options.logging && console.log.apply(console, arguments);\n  },\n  calcTTL: function (ttl) {\n    let now = new Date();\n    let nowts = now.getTime();\n\n    // only check for undefined, if null was passed in setItem then we probably didn't want to use the this.options.ttl\n    if (typeof ttl === 'undefined') {\n      ttl = this.options.ttl;\n    }\n    if (ttl) {\n      if (isDate(ttl)) {\n        if (!isFutureDate(ttl)) {\n          ttl = defaultTTL;\n        }\n        ttl = ttl.getTime ? ttl.getTime() : ttl;\n      } else {\n        ttl = ttl ? isNumber(ttl) && ttl > 0 ? nowts + ttl : defaultTTL : void 0;\n      }\n      return ttl;\n    } else {\n      return void 0;\n    }\n  }\n};\nmodule.exports = LocalStorage;","map":{"version":3,"names":["fs","require","path","crypto","pkg","nextTick","defaults","ttl","logging","encoding","parse","JSON","stringify","forgiveParseErrors","expiredInterval","dir","name","writeQueue","writeQueueIntervalMs","writeQueueWriteOnlyLast","defaultTTL","isFunction","fn","isNumber","n","isNaN","parseFloat","isFinite","isDate","d","Object","prototype","toString","call","isValidDate","isFutureDate","getTime","Date","sha256","key","createHash","update","digest","isValidStorageFileContent","content","isExpired","datum","isNotExpired","resolveDir","normalize","isAbsolute","join","process","cwd","LocalStorage","options","setOptions","init","ensureDirectory","startExpiredKeysInterval","q","startWriteQueueInterval","initSync","ensureDirectorySync","userOptions","hasOwnProperty","log","data","readDirectory","keys","filter","map","values","value","length","forEach","callback","valuesWithKeyMatch","match","RegExp","test","indexOf","set","arguments","undefined","setItem","datumValue","copy","calcTTL","concat","queueWriteFile","getDatumPath","updateItem","previousDatum","getDatum","newDatumValue","get","getItem","removeItem","readFile","getRawDatum","raw","getDatumValue","del","rm","deleteFile","removeExpiredItems","clear","Promise","resolve","reject","result","access","accessErr","mkdir","recursive","err","accessSync","e","mkdirSync","readdir","arr","currentFile","push","Error","file","text","code","input","writeFile","processWriteQueue","processingWriteQueue","promises","writeItem","pop","shift","ret","writeItem0","all","_writeQueueInterval","setInterval","unref","stopWriteQueueInterval","clearInterval","unlink","removed","existed","obj","str","stopExpiredKeysInterval","_expiredKeysInterval","bind","console","apply","now","nowts","module","exports"],"sources":["C:/Users/kiran/OneDrive/Desktop/frontend-live-coding-exercise-react-main/node_modules/node-persist/src/local-storage.js"],"sourcesContent":["/*\n * Simon Last, Sept 2013\n * http://simonlast.org\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\nconst pkg = require('../package.json');\nconst { nextTick } = require('process');\n\nconst defaults = {\n\tttl: false,\n\tlogging: false,\n\tencoding: 'utf8',\n\tparse: JSON.parse,\n\tstringify: JSON.stringify,\n\tforgiveParseErrors: false,\n\texpiredInterval: 2 * 60 * 1000, /* every 2 minutes */\n\tdir: '.' + pkg.name + '/storage',\n\twriteQueue: true,\n\twriteQueueIntervalMs: 1000,\n\twriteQueueWriteOnlyLast: true,\n};\n\nconst defaultTTL = 24 * 60 * 60 * 1000; /* if ttl is truthy but it's not a number, use 24h as default */\n\nconst isFunction = function(fn) {\n\treturn typeof fn === 'function';\n};\n\nconst isNumber = function(n) {\n\treturn !isNaN(parseFloat(n)) && isFinite(n);\n};\n\nconst isDate = function(d) {\n\treturn Object.prototype.toString.call(d) === '[object Date]';\n};\n\nconst isValidDate = function(d) {\n\treturn isDate(d) && !isNaN(d);\n};\n\nconst isFutureDate = function(d) {\n\treturn isValidDate(d) && d.getTime() > (+new Date);\n};\n\nconst sha256 = function (key) {\n\treturn crypto.createHash('sha256').update(key).digest('hex');\n};\n\nconst isValidStorageFileContent = function (content) {\n\treturn content && content.key;\n};\n\nconst isExpired = function (datum) {\n\treturn datum && datum.ttl && datum.ttl < (new Date()).getTime();\n};\n\nconst isNotExpired = function (datum) {\n\treturn !isExpired(datum);\n};\n\nconst resolveDir = function(dir) {\n\tdir = path.normalize(dir);\n\tif (path.isAbsolute(dir)) {\n\t\treturn dir;\n\t}\n\treturn path.join(process.cwd(), dir);\n};\n\nconst LocalStorage = function (options) {\n\tif(!(this instanceof LocalStorage)) {\n\t\treturn new LocalStorage(options);\n\t}\n\tthis.setOptions(options);\n};\n\nLocalStorage.prototype = {\n\n\tinit: async function (options) {\n\t\tif (options) {\n\t\t\tthis.setOptions(options);\n\t\t}\n\t\tawait this.ensureDirectory(this.options.dir);\n\t\tif (this.options.expiredInterval) {\n\t\t\tthis.startExpiredKeysInterval();\n\t\t}\n\t\tthis.q = {}\n\t\tthis.startWriteQueueInterval();\n\t\treturn this.options;\n\t},\n\n\tinitSync: function (options) {\n\t\tif (options) {\n\t\t\tthis.setOptions(options);\n\t\t}\n\t\tthis.ensureDirectorySync(this.options.dir);\n\t\tif (this.options.expiredInterval) {\n\t\t\tthis.startExpiredKeysInterval();\n\t\t}\n\t\tthis.q = {}\n\t\tthis.startWriteQueueInterval();\n\t\treturn this.options;\n\t},\n\n\tsetOptions: function (userOptions) {\n\t\tlet options = {};\n\n\t\tif (!userOptions) {\n\t\t\toptions = defaults;\n\t\t} else {\n\t\t\tfor (let key in defaults) {\n\t\t\t\tif (userOptions.hasOwnProperty(key)) {\n\t\t\t\t\toptions[key] = userOptions[key];\n\t\t\t\t} else {\n\t\t\t\t\toptions[key] = this.options && this.options[key] != null ? this.options[key] : defaults[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\toptions.dir = resolveDir(options.dir);\n\t\t\toptions.ttl = options.ttl ? isNumber(options.ttl) && options.ttl > 0 ? options.ttl : defaultTTL : false;\n\t\t}\n\n\t\t// Check to see if we received an external logging function\n\t\tif (isFunction(options.logging)) {\n\t\t\t// Overwrite log function with external logging function\n\t\t\tthis.log = options.logging;\n\t\t\toptions.logging = true;\n\t\t}\n\t\tthis.options = options;\n\t},\n\n\tdata: function () {\n\t\treturn this.readDirectory(this.options.dir);\n\t},\n\n\tkeys: async function (filter) {\n\t\tlet data = await this.data();\n\t\tif (filter) {\n\t\t\tdata = data.filter(filter);\n\t\t}\n\t\treturn data.map(datum => datum.key);\n\t},\n\n\tvalues: async function (filter) {\n\t\tlet data = await this.data();\n\t\tif (filter) {\n\t\t\tdata = data.filter(filter);\n\t\t}\n\t\treturn data.map(datum => datum.value);\n\t},\n\n\tlength: async function (filter) {\n\t\tlet data = await this.data();\n\t\tif (filter) {\n\t\t\tdata = data.filter(filter);\n\t\t}\n\t\treturn data.length;\n\t},\n\n\tforEach: async function(callback) {\n\t\tlet data = await this.data();\n\t\tfor (let d of data) {\n\t\t\tawait callback(d);\n\t\t}\n\t},\n\n\tvaluesWithKeyMatch: function(match) {\n\t\tmatch = match || /.*/;\n\t\tlet filter = match instanceof RegExp ? datum => match.test(datum.key) : datum => datum.key.indexOf(match) !== -1;\n\t\treturn this.values(filter);\n\t},\n\n\tset: function (key, value, options = {}) {\n\t\treturn this.setItem(key, value, options);\n\t},\n\n\tsetItem: function (key, datumValue, options = {}) {\n\t\tlet value = this.copy(datumValue);\n\t\tlet ttl = this.calcTTL(options.ttl);\n\t\tthis.log(`set ('${key}': '${this.stringify(value)}')`);\n\t\tlet datum = { key, value, ttl };\n\t\treturn this.queueWriteFile(this.getDatumPath(key), datum);\n\t},\n\n\tupdate: function (key, value, options = {}) {\n\t\treturn this.updateItem(key, value, options);\n\t},\n\n\tupdateItem: async function (key, datumValue, options = {}) {\n\t\tlet previousDatum = await this.getDatum(key);\n\t\tif (previousDatum && isNotExpired(previousDatum)) {\n\t\t\tlet newDatumValue = this.copy(datumValue);\n\t\t\tlet ttl;\n\t\t\tif (options.ttl) {\n\t\t\t\tttl = this.calcTTL(options.ttl);\n\t\t\t} else {\n\t\t\t\tttl = previousDatum.ttl;\n\t\t\t}\n\t\t\tthis.log(`update ('${key}': '${this.stringify(newDatumValue)}')`);\n\t\t\tlet datum = { key, value: newDatumValue, ttl };\n\t\t\treturn this.queueWriteFile(this.getDatumPath(key), datum);\n\t\t} else {\n\t\t\treturn this.setItem(key, datumValue, options);\n\t\t}\n\t},\n\n\tget: function (key) {\n\t\treturn this.getItem(key);\n\t},\n\n\tgetItem: async function (key) {\n\t\tlet datum = await this.getDatum(key);\n\t\tif (isExpired(datum)) {\n\t\t\tthis.log(`${key} has expired`);\n\t\t\tawait this.removeItem(key);\n\t\t} else {\n\t\t\treturn datum.value;\n\t\t}\n\t},\n\n\tgetDatum: function (key) {\n\t\treturn this.readFile(this.getDatumPath(key));\n\t},\n\n\tgetRawDatum: function (key) {\n\t\treturn this.readFile(this.getDatumPath(key), {raw: true});\n\t},\n\n\tgetDatumValue: async function (key) {\n\t\tlet datum = await this.getDatum(key);\n\t\treturn datum && datum.value;\n\t},\n\n\tgetDatumPath: function (key) {\n\t\treturn path.join(this.options.dir, sha256(key));\n\t},\n\n\tdel: function (key) {\n\t\treturn this.removeItem(key);\n\t},\n\n\trm: function (key) {\n\t\treturn this.removeItem(key);\n\t},\n\n\tremoveItem: function (key) {\n\t\treturn this.deleteFile(this.getDatumPath(key));\n\t},\n\n\tremoveExpiredItems: async function () {\n\t\tlet keys = await this.keys(isExpired);\n\t\tfor (let key of keys) {\n\t\t\tawait this.removeItem(key);\n\t\t}\n\t},\n\n\tclear: async function () {\n\t\tlet data = await this.data();\n\t\tfor (let d of data) {\n\t\t\tawait this.removeItem(d.key);\n\t\t}\n\t},\n\n\tensureDirectory: function (dir) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet result = {dir: dir};\n\t\t\tfs.access(dir, (accessErr) => {\n\t\t\t\tif (!accessErr) {\n\t\t\t\t\treturn resolve(result);\n\t\t\t\t} else {\n\t\t\t\t\tfs.mkdir(dir, { recursive: true }, (err) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.log('created ' + dir);\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\tensureDirectorySync: function (dir) {\n\t\tlet result = {dir: dir};\n\t\ttry {\n\t\t\tfs.accessSync(dir)\n\t\t\treturn result\n\t\t} catch (e) {\n\t\t\tfs.mkdirSync(dir, { recursive: true })\n\t\t\tthis.log('created ' + dir);\n\t\t\treturn result\n\t\t}\n\t},\n\n\treadDirectory: function (dir) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\t//check to see if dir is present\n\t\t\tfs.access(dir, (accessErr) => {\n\t\t\t\tif (!accessErr) {\n\t\t\t\t\t//load data\n\t\t\t\t\tfs.readdir(dir, async (err, arr) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet data = [];\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfor (let currentFile of arr) {\n\t\t\t\t\t\t\t\tif (currentFile[0] !== '.') {\n\t\t\t\t\t\t\t\t\tdata.push(await this.readFile(path.join(this.options.dir, currentFile)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\treject(err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error(`[node-persist][readDirectory] ${dir} does not exists!`));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\treadFile: function (file, options = {}) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfs.readFile(file, this.options.encoding, (err, text) => {\n\t\t\t\tif (err) {\n\t\t\t\t\t/* Only throw the error if the error is something else other than the file doesn't exist */\n\t\t\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\t\t\tthis.log(`${file} does not exist, returning undefined value`);\n\t\t\t\t\t\tresolve(options.raw ? '{}' : {});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet input = options.raw ? text : this.parse(text);\n\t\t\t\tif (!options.raw && !isValidStorageFileContent(input)) {\n\t\t\t\t\treturn this.options.forgiveParseErrors ? resolve(options.raw ? '{}' : {}) : reject(new Error(`[node-persist][readFile] ${file} does not look like a valid storage file!`));\n\t\t\t\t}\n\t\t\t\tresolve(input);\n\t\t\t});\n\t\t});\n\t},\n\n\tqueueWriteFile: async function (file, content) {\n\t\tif (this.options.writeQueue === false) {\n\t\t\treturn this.writeFile(file, content)\t\t\t\n\t\t}\n\t\tthis.q[file] = this.q[file] || []\n\t\tnextTick(() => {\n\t\t\tthis.startWriteQueueInterval()\n\t\t})\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.q[file].push({ content, resolve, reject })\n\t\t})\n\t},\n\t\n\tprocessWriteQueue: async function () {\n\t\tif (this.processingWriteQueue) {\n\t\t\tthis.log('Still processing write queue, waiting...');\n\t\t\treturn\n\t\t}\n\t\tthis.processingWriteQueue = true\n\t\tconst promises = Object.keys(this.q).map(async file => {\n\t\t\tlet writeItem\n\t\t\tif (this.options.writeQueueWriteOnlyLast) {\n\t\t\t\t// lifo\n\t\t\t\twriteItem = this.q[file].pop()\n\t\t\t} else {\n\t\t\t\t// fifo\n\t\t\t\twriteItem = this.q[file].shift()\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst ret = await this.writeFile(file, writeItem.content)\n\t\t\t\tif (this.options.writeQueueWriteOnlyLast) {\n\t\t\t\t\twhile (this.q[file].length) {\n\t\t\t\t\t\tconst writeItem0 = this.q[file].shift()\n\t\t\t\t\t\twriteItem0.resolve(ret)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twriteItem.resolve(ret)\n\t\t\t} catch (e) {\n\t\t\t\twhile (this.q[file].length) {\n\t\t\t\t\tconst writeItem0 = this.q[file].shift()\n\t\t\t\t\twriteItem0.reject(e)\n\t\t\t\t}\n\t\t\t\twriteItem.reject(e)\n\t\t\t}\n\t\t\tif (!this.q[file] || !this.q[file].length) {\n\t\t\t\tdelete this.q[file]\n\t\t\t}\n\t\t})\n\t\ttry {\n\t\t\tawait Promise.all(promises)\n\t\t} finally {\n\t\t\tthis.processingWriteQueue = false\n\t\t}\n\t},\n\t\n\tstartWriteQueueInterval: function () {\n\t\tthis.processWriteQueue()\n\t\tif (!this._writeQueueInterval) {\n\t\t\tthis._writeQueueInterval = setInterval(() => this.processWriteQueue(), this.options.writeQueueIntervalMs || 1000)\n\t\t\tthis._writeQueueInterval.unref && this._writeQueueInterval.unref();\n\t\t}\n\t},\n\n\tstopWriteQueueInterval: function () {\n\t\tclearInterval(this._writeQueueInterval);\n\t},\n\n\twriteFile: async function (file, content) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfs.writeFile(file, this.stringify(content), this.options.encoding, async (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn reject(err);\n\t\t\t\t}\n\t\t\t\tresolve({file: file, content: content});\n\t\t\t\tthis.log('wrote: ' + file);\n\t\t\t});\n\t\t});\n\t},\n\n\tdeleteFile: function (file) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfs.access(file, (accessErr) => {\n\t\t\t\tif (!accessErr) {\n\t\t\t\t\tthis.log(`Removing file:${file}`);\n\t\t\t\t\tfs.unlink(file, (err) => {\n\t\t\t\t\t\t/* Only throw the error if the error is something else */\n\t\t\t\t\t\tif (err && err.code !== 'ENOENT') {\n\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet result = {file: file, removed: !err, existed: !accessErr};\n\t\t\t\t\t\terr && this.log(`Failed to remove file:${file} because it doesn't exist anymore.`);\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis.log(`Not removing file:${file} because it doesn't exist`);\n\t\t\t\t\tlet result = {file: file, removed: false, existed: false};\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\tstringify: function (obj) {\n\t\treturn this.options.stringify(obj);\n\t},\n\n\tparse: function(str) {\n\t\tif (str == null) {\n\t\t\treturn undefined;\n\t\t}\n\t\ttry {\n\t\t\treturn this.options.parse(str);\n\t\t} catch(e) {\n\t\t\tthis.log('parse error: ', this.stringify(e), 'for:', str);\n\t\t\treturn undefined;\n\t\t}\n\t},\n\n\tcopy: function (value) {\n\t\t// don't copy literals since they're passed by value\n\t\tif (typeof value !== 'object') {\n\t\t\treturn value;\n\t\t}\n\t\treturn this.parse(this.stringify(value));\n\t},\n\n\tstartExpiredKeysInterval: function () {\n\t\tthis.stopExpiredKeysInterval();\n\t\tthis._expiredKeysInterval = setInterval(this.removeExpiredItems.bind(this), this.options.expiredInterval);\n\t\tthis._expiredKeysInterval.unref && this._expiredKeysInterval.unref();\n\t},\n\n\tstopExpiredKeysInterval: function () {\n\t\tclearInterval(this._expiredKeysInterval);\n\t},\n\n\tlog: function () {\n\t\tthis.options && this.options.logging && console.log.apply(console, arguments);\n\t},\n\n\tcalcTTL: function (ttl) {\n\t\tlet now = new Date();\n\t\tlet nowts = now.getTime();\n\n\t\t// only check for undefined, if null was passed in setItem then we probably didn't want to use the this.options.ttl\n\t\tif (typeof ttl === 'undefined') {\n\t\t\tttl = this.options.ttl;\n\t\t}\n\n\t\tif (ttl) {\n\t\t\tif (isDate(ttl)) {\n\t\t\t\tif (!isFutureDate(ttl)) {\n\t\t\t\t\tttl = defaultTTL;\n\t\t\t\t}\n\t\t\t\tttl = ttl.getTime ? ttl.getTime() : ttl;\n\t\t\t} else {\n\t\t\t\tttl = ttl ? isNumber(ttl) && ttl > 0 ? nowts + ttl : defaultTTL : void 0;\n\t\t\t}\n\t\t\treturn ttl;\n\t\t} else {\n\t\t\treturn void 0;\n\t\t}\n\t}\n};\n\nmodule.exports = LocalStorage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}